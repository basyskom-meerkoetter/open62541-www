<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Data Types &mdash; open62541 1.4.0-rc1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/documentation_options.js?v=c0a96e6d"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Services" href="services.html" />
    <link rel="prev" title="Subscribing Fields" href="tutorial_pubsub_subscribe.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="toc.html" class="icon icon-home">
            open62541
              <img src="_static/open62541_html.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="core_concepts.html">Core Concepts of OPC UA</a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html">Building open62541</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Data Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#builtin-types">Builtin Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#boolean">Boolean</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sbyte">SByte</a></li>
<li class="toctree-l3"><a class="reference internal" href="#byte">Byte</a></li>
<li class="toctree-l3"><a class="reference internal" href="#int16">Int16</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uint16">UInt16</a></li>
<li class="toctree-l3"><a class="reference internal" href="#int32">Int32</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uint32">UInt32</a></li>
<li class="toctree-l3"><a class="reference internal" href="#int64">Int64</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uint64">UInt64</a></li>
<li class="toctree-l3"><a class="reference internal" href="#float">Float</a></li>
<li class="toctree-l3"><a class="reference internal" href="#double">Double</a></li>
<li class="toctree-l3"><a class="reference internal" href="#statuscode">StatusCode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#string">String</a></li>
<li class="toctree-l3"><a class="reference internal" href="#datetime">DateTime</a></li>
<li class="toctree-l3"><a class="reference internal" href="#guid">Guid</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bytestring">ByteString</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xmlelement">XmlElement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nodeid">NodeId</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expandednodeid">ExpandedNodeId</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qualifiedname">QualifiedName</a></li>
<li class="toctree-l3"><a class="reference internal" href="#localizedtext">LocalizedText</a></li>
<li class="toctree-l3"><a class="reference internal" href="#numericrange">NumericRange</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variant">Variant</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extensionobject">ExtensionObject</a></li>
<li class="toctree-l3"><a class="reference internal" href="#datavalue">DataValue</a></li>
<li class="toctree-l3"><a class="reference internal" href="#diagnosticinfo">DiagnosticInfo</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#generic-type-handling">Generic Type Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#binary-encoding-decoding">Binary Encoding/Decoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#json-en-decoding">JSON En/Decoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xml-en-decoding">XML En/Decoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#array-handling">Array handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generated-data-type-definitions">Generated Data Type Definitions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="services.html">Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="server.html">Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="client.html">Client</a></li>
<li class="toctree-l1"><a class="reference internal" href="pubsub.html">PubSub</a></li>
<li class="toctree-l1"><a class="reference internal" href="common.html">Common Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="nodeset_compiler.html">XML Nodeset Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugin.html">Plugin API</a></li>
<li class="toctree-l1"><a class="reference internal" href="generated.html">Generated Definitions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="toc.html">open62541</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="toc.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Data Types</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/types.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="data-types">
<span id="types"></span><h1>Data Types<a class="headerlink" href="#data-types" title="Link to this heading">¶</a></h1>
<p>The OPC UA protocol defines 25 builtin data types and three ways of combining
them into higher-order types: arrays, structures and unions. In open62541,
only the builtin data types are defined manually. All other data types are
generated from standard XML definitions. Their exact definitions can be
looked up at <a class="reference external" href="https://opcfoundation.org/UA/schemas/Opc.Ua.Types.bsd">https://opcfoundation.org/UA/schemas/Opc.Ua.Types.bsd</a>.</p>
<p>For users that are new to open62541, take a look at the <a class="reference internal" href="tutorial_datatypes.html#types-tutorial"><span class="std std-ref">tutorial for
working with data types</span></a> before diving into the
implementation details.</p>
<section id="builtin-types">
<h2>Builtin Types<a class="headerlink" href="#builtin-types" title="Link to this heading">¶</a></h2>
<section id="boolean">
<h3>Boolean<a class="headerlink" href="#boolean" title="Link to this heading">¶</a></h3>
<p>A two-state logical value (true or false).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">UA_Boolean</span><span class="p">;</span>
<span class="cp">#define UA_TRUE true UA_INTERNAL_DEPRECATED</span>
<span class="cp">#define UA_FALSE false UA_INTERNAL_DEPRECATED</span>
</pre></div>
</div>
</section>
<section id="sbyte">
<h3>SByte<a class="headerlink" href="#sbyte" title="Link to this heading">¶</a></h3>
<p>An integer value between -128 and 127.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">UA_SByte</span><span class="p">;</span>
<span class="cp">#define UA_SBYTE_MIN (-128)</span>
<span class="cp">#define UA_SBYTE_MAX 127</span>
</pre></div>
</div>
</section>
<section id="byte">
<h3>Byte<a class="headerlink" href="#byte" title="Link to this heading">¶</a></h3>
<p>An integer value between 0 and 255.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">UA_Byte</span><span class="p">;</span>
<span class="cp">#define UA_BYTE_MIN 0</span>
<span class="cp">#define UA_BYTE_MAX 255</span>
</pre></div>
</div>
</section>
<section id="int16">
<h3>Int16<a class="headerlink" href="#int16" title="Link to this heading">¶</a></h3>
<p>An integer value between -32 768 and 32 767.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int16_t</span><span class="w"> </span><span class="n">UA_Int16</span><span class="p">;</span>
<span class="cp">#define UA_INT16_MIN (-32768)</span>
<span class="cp">#define UA_INT16_MAX 32767</span>
</pre></div>
</div>
</section>
<section id="uint16">
<h3>UInt16<a class="headerlink" href="#uint16" title="Link to this heading">¶</a></h3>
<p>An integer value between 0 and 65 535.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">UA_UInt16</span><span class="p">;</span>
<span class="cp">#define UA_UINT16_MIN 0</span>
<span class="cp">#define UA_UINT16_MAX 65535</span>
</pre></div>
</div>
</section>
<section id="int32">
<h3>Int32<a class="headerlink" href="#int32" title="Link to this heading">¶</a></h3>
<p>An integer value between -2 147 483 648 and 2 147 483 647.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">UA_Int32</span><span class="p">;</span>
<span class="cp">#define UA_INT32_MIN ((int32_t)-2147483648LL)</span>
<span class="cp">#define UA_INT32_MAX 2147483647L</span>
</pre></div>
</div>
</section>
<section id="uint32">
<h3>UInt32<a class="headerlink" href="#uint32" title="Link to this heading">¶</a></h3>
<p>An integer value between 0 and 4 294 967 295.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">UA_UInt32</span><span class="p">;</span>
<span class="cp">#define UA_UINT32_MIN 0</span>
<span class="cp">#define UA_UINT32_MAX 4294967295UL</span>
</pre></div>
</div>
</section>
<section id="int64">
<h3>Int64<a class="headerlink" href="#int64" title="Link to this heading">¶</a></h3>
<p>An integer value between -9 223 372 036 854 775 808 and
9 223 372 036 854 775 807.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">UA_Int64</span><span class="p">;</span>
<span class="cp">#define UA_INT64_MAX (int64_t)9223372036854775807LL</span>
<span class="cp">#define UA_INT64_MIN ((int64_t)-UA_INT64_MAX-1LL)</span>
</pre></div>
</div>
</section>
<section id="uint64">
<h3>UInt64<a class="headerlink" href="#uint64" title="Link to this heading">¶</a></h3>
<p>An integer value between 0 and 18 446 744 073 709 551 615.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">UA_UInt64</span><span class="p">;</span>
<span class="cp">#define UA_UINT64_MIN 0</span>
<span class="cp">#define UA_UINT64_MAX (uint64_t)18446744073709551615ULL</span>
</pre></div>
</div>
</section>
<section id="float">
<h3>Float<a class="headerlink" href="#float" title="Link to this heading">¶</a></h3>
<p>An IEEE single precision (32 bit) floating point value.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">UA_Float</span><span class="p">;</span>
<span class="cp">#define UA_FLOAT_MIN FLT_MIN;</span>
<span class="cp">#define UA_FLOAT_MAX FLT_MAX;</span>
</pre></div>
</div>
</section>
<section id="double">
<h3>Double<a class="headerlink" href="#double" title="Link to this heading">¶</a></h3>
<p>An IEEE double precision (64 bit) floating point value.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">UA_Double</span><span class="p">;</span>
<span class="cp">#define UA_DOUBLE_MIN DBL_MIN;</span>
<span class="cp">#define UA_DOUBLE_MAX DBL_MAX;</span>
</pre></div>
</div>
</section>
<section id="statuscode">
<span id="id1"></span><h3>StatusCode<a class="headerlink" href="#statuscode" title="Link to this heading">¶</a></h3>
<p>A numeric identifier for an error or condition that is associated with a
value or an operation. See the section <a class="reference internal" href="statuscodes.html#statuscodes"><span class="std std-ref">StatusCodes</span></a> for the meaning of
a specific code.</p>
<p>Each StatusCode has one of three “severity” bit-flags:
Good, Uncertain, Bad. An additional reason is indicated by the SubCode
bitfield.</p>
<ul class="simple">
<li><p>A StatusCode with severity Good means that the value is of good quality.</p></li>
<li><p>A StatusCode with severity Uncertain means that the quality of the value is
uncertain for reasons indicated by the SubCode.</p></li>
<li><p>A StatusCode with severity Bad means that the value is not usable for
reasons indicated by the SubCode.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">UA_StatusCode</span><span class="p">;</span>

<span class="cm">/* Returns the human-readable name of the StatusCode. If no matching StatusCode</span>
<span class="cm"> * is found, a default string for &quot;Unknown&quot; is returned. This feature might be</span>
<span class="cm"> * disabled to create a smaller binary with the</span>
<span class="cm"> * UA_ENABLE_STATUSCODE_DESCRIPTIONS build-flag. Then the function returns an</span>
<span class="cm"> * empty string for every StatusCode. */</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span>
<span class="nf">UA_StatusCode_name</span><span class="p">(</span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="n">code</span><span class="p">);</span>

<span class="cm">/* Extracts the severity from a StatusCode. See Part 4, Section 7.34 for</span>
<span class="cm"> * details. */</span>
<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_StatusCode_isBad</span><span class="p">(</span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="n">code</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">code</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mh">0x02</span><span class="p">);</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_StatusCode_isUncertain</span><span class="p">(</span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="n">code</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">code</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x01</span><span class="p">);</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_StatusCode_isGood</span><span class="p">(</span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="n">code</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">code</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x00</span><span class="p">);</span>
<span class="p">})</span>

<span class="cm">/* Compares the top 16 bits of two StatusCodes for equality. This should only</span>
<span class="cm"> * be used when processing user-defined StatusCodes e.g when processing a ReadResponse.</span>
<span class="cm"> * As a convention, the lower bits of StatusCodes should not be used internally, meaning</span>
<span class="cm"> * can compare them without the use of this function. */</span>
<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_StatusCode_isEqualTop</span><span class="p">(</span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="n">s2</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">s1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFF0000</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">s2</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFF0000</span><span class="p">));</span>
<span class="p">})</span>
</pre></div>
</div>
</section>
<section id="string">
<h3>String<a class="headerlink" href="#string" title="Link to this heading">¶</a></h3>
<p>A sequence of Unicode characters. Strings are just an array of UA_Byte.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="cm">/* The length of the string */</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="cm">/* The content (not null-terminated) */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_String</span><span class="p">;</span>

<span class="cm">/* Copies the content on the heap. Returns a null-string when alloc fails */</span>
<span class="n">UA_String</span>
<span class="nf">UA_String_fromChars</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">);</span>

<span class="n">UA_Boolean</span>
<span class="nf">UA_String_isEmpty</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="n">UA_STRING_NULL</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UA_STRING</span></code> returns a string pointing to the original char-array.
<code class="docutils literal notranslate"><span class="pre">UA_STRING_ALLOC</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">UA_String_fromChars</span></code> and makes a copy
of the char-array.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_String</span>
<span class="w">             </span><span class="n">UA_STRING</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_String</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">chars</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UA_Byte</span><span class="o">*</span><span class="p">)</span><span class="n">chars</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="p">})</span>

<span class="cp">#define UA_STRING_ALLOC(CHARS) UA_String_fromChars(CHARS)</span>

<span class="cm">/* Define strings at compile time (in ROM) */</span>
<span class="cp">#define UA_STRING_STATIC(CHARS) {sizeof(CHARS)-1, (UA_Byte*)CHARS}</span>
</pre></div>
</div>
</section>
<section id="datetime">
<span id="id2"></span><h3>DateTime<a class="headerlink" href="#datetime" title="Link to this heading">¶</a></h3>
<p>An instance in time. A DateTime value is encoded as a 64-bit signed integer
which represents the number of 100 nanosecond intervals since January 1, 1601
(UTC).</p>
<p>The methods providing an interface to the system clock are architecture-
specific. Usually, they provide a UTC clock that includes leap seconds. The
OPC UA standard allows the use of International Atomic Time (TAI) for the
DateTime instead. But this is still unusual and not implemented for most
SDKs. Currently (2019), UTC and TAI are 37 seconds apart due to leap
seconds.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">UA_DateTime</span><span class="p">;</span>

<span class="cm">/* Multiples to convert durations to DateTime */</span>
<span class="cp">#define UA_DATETIME_USEC 10LL</span>
<span class="cp">#define UA_DATETIME_MSEC (UA_DATETIME_USEC * 1000LL)</span>
<span class="cp">#define UA_DATETIME_SEC (UA_DATETIME_MSEC * 1000LL)</span>

<span class="cm">/* The current time in UTC time */</span>
<span class="n">UA_DateTime</span><span class="w"> </span><span class="nf">UA_DateTime_now</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Offset between local time and UTC time */</span>
<span class="n">UA_Int64</span><span class="w"> </span><span class="nf">UA_DateTime_localTimeUtcOffset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* CPU clock invariant to system time changes. Use only to measure durations,</span>
<span class="cm"> * not absolute time. */</span>
<span class="n">UA_DateTime</span><span class="w"> </span><span class="nf">UA_DateTime_nowMonotonic</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Represents a Datetime as a structure */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_DateTimeStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nanoSec</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">microSec</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">milliSec</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">sec</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">min</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">hour</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">day</span><span class="p">;</span><span class="w">   </span><span class="cm">/* From 1 to 31 */</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">month</span><span class="p">;</span><span class="w"> </span><span class="cm">/* From 1 to 12 */</span>
<span class="w">    </span><span class="n">UA_Int16</span><span class="w"> </span><span class="n">year</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Can be negative (BC) */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DateTimeStruct</span><span class="p">;</span>

<span class="n">UA_DateTimeStruct</span><span class="w"> </span><span class="nf">UA_DateTime_toStruct</span><span class="p">(</span><span class="n">UA_DateTime</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="n">UA_DateTime</span><span class="w"> </span><span class="nf">UA_DateTime_fromStruct</span><span class="p">(</span><span class="n">UA_DateTimeStruct</span><span class="w"> </span><span class="n">ts</span><span class="p">);</span>

<span class="cm">/* The C99 standard (7.23.1) says: &quot;The range and precision of times</span>
<span class="cm"> * representable in clock_t and time_t are implementation-defined.&quot; On most</span>
<span class="cm"> * systems, time_t is a 4 or 8 byte integer counting seconds since the UTC Unix</span>
<span class="cm"> * epoch. The following methods are used for conversion. */</span>

<span class="cm">/* Datetime of 1 Jan 1970 00:00 */</span>
<span class="cp">#define UA_DATETIME_UNIX_EPOCH (11644473600LL * UA_DATETIME_SEC)</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Int64</span>
<span class="w">             </span><span class="n">UA_DateTime_toUnixTime</span><span class="p">(</span><span class="n">UA_DateTime</span><span class="w"> </span><span class="n">date</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">date</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">UA_DATETIME_UNIX_EPOCH</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">UA_DATETIME_SEC</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_DateTime</span>
<span class="w">             </span><span class="n">UA_DateTime_fromUnixTime</span><span class="p">(</span><span class="n">UA_Int64</span><span class="w"> </span><span class="n">unixDate</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">unixDate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">UA_DATETIME_SEC</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UA_DATETIME_UNIX_EPOCH</span><span class="p">;</span>
<span class="p">})</span>
</pre></div>
</div>
</section>
<section id="guid">
<h3>Guid<a class="headerlink" href="#guid" title="Link to this heading">¶</a></h3>
<p>A 16 byte value that can be used as a globally unique identifier.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">data1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">data2</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">data3</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w">   </span><span class="n">data4</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_Guid</span><span class="p">;</span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_Guid</span><span class="w"> </span><span class="n">UA_GUID_NULL</span><span class="p">;</span>

<span class="cm">/* Print a Guid in the human-readable format defined in Part 6, 5.1.3</span>
<span class="cm"> *</span>
<span class="cm"> * Format: C496578A-0DFE-4B8F-870A-745238C6AEAE</span>
<span class="cm"> *         |       |    |    |    |            |</span>
<span class="cm"> *         0       8    13   18   23           36</span>
<span class="cm"> *</span>
<span class="cm"> * This allocates memory if the output argument is an empty string. Tries to use</span>
<span class="cm"> * the given buffer otherwise. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Guid_print</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_Guid</span><span class="w"> </span><span class="o">*</span><span class="n">guid</span><span class="p">,</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">);</span>

<span class="cm">/* Parse the humand-readable Guid format */</span>
<span class="cp">#ifdef UA_ENABLE_PARSING</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Guid_parse</span><span class="p">(</span><span class="n">UA_Guid</span><span class="w"> </span><span class="o">*</span><span class="n">guid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Guid</span>
<span class="w">             </span><span class="n">UA_GUID</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_Guid</span><span class="w"> </span><span class="n">guid</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Guid_parse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">guid</span><span class="p">,</span><span class="w"> </span><span class="n">UA_STRING</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">chars</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">guid</span><span class="p">;</span>
<span class="p">})</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
<section id="bytestring">
<h3>ByteString<a class="headerlink" href="#bytestring" title="Link to this heading">¶</a></h3>
<p>A sequence of octets.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="n">UA_ByteString</span><span class="p">;</span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="n">UA_BYTESTRING_NULL</span><span class="p">;</span>

<span class="cm">/* Allocates memory of size length for the bytestring.</span>
<span class="cm"> * The content is not set to zero. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_ByteString_allocBuffer</span><span class="p">(</span><span class="n">UA_ByteString</span><span class="w"> </span><span class="o">*</span><span class="n">bs</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>

<span class="cm">/* Converts a ByteString to the corresponding</span>
<span class="cm"> * base64 representation */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_ByteString_toBase64</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="o">*</span><span class="n">bs</span><span class="p">,</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">);</span>

<span class="cm">/* Parse a ByteString from a base64 representation */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_ByteString_fromBase64</span><span class="p">(</span><span class="n">UA_ByteString</span><span class="w"> </span><span class="o">*</span><span class="n">bs</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">);</span>

<span class="cp">#define UA_BYTESTRING(chars) UA_STRING(chars)</span>
<span class="cp">#define UA_BYTESTRING_ALLOC(chars) UA_STRING_ALLOC(chars)</span>

<span class="cm">/* Returns a non-cryptographic hash of a bytestring */</span>
<span class="n">UA_UInt32</span>
<span class="nf">UA_ByteString_hash</span><span class="p">(</span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">initialHashValue</span><span class="p">,</span>
<span class="w">                   </span><span class="k">const</span><span class="w"> </span><span class="n">UA_Byte</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="xmlelement">
<h3>XmlElement<a class="headerlink" href="#xmlelement" title="Link to this heading">¶</a></h3>
<p>An XML element.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="n">UA_XmlElement</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="nodeid">
<span id="id3"></span><h3>NodeId<a class="headerlink" href="#nodeid" title="Link to this heading">¶</a></h3>
<p>An identifier for a node in the address space of an OPC UA Server.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">UA_NodeIdType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NODEIDTYPE_NUMERIC</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="cm">/* In the binary encoding, this can also</span>
<span class="cm">                                   * become 1 or 2 (two-byte and four-byte</span>
<span class="cm">                                   * encoding of small numeric nodeids) */</span>
<span class="w">    </span><span class="n">UA_NODEIDTYPE_STRING</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_NODEIDTYPE_GUID</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_NODEIDTYPE_BYTESTRING</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>
<span class="p">};</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">namespaceIndex</span><span class="p">;</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">UA_NodeIdType</span><span class="w"> </span><span class="n">identifierType</span><span class="p">;</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UA_UInt32</span><span class="w">     </span><span class="n">numeric</span><span class="p">;</span>
<span class="w">        </span><span class="n">UA_String</span><span class="w">     </span><span class="n">string</span><span class="p">;</span>
<span class="w">        </span><span class="n">UA_Guid</span><span class="w">       </span><span class="n">guid</span><span class="p">;</span>
<span class="w">        </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="n">byteString</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">identifier</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="p">;</span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">UA_NODEID_NULL</span><span class="p">;</span>

<span class="n">UA_Boolean</span><span class="w"> </span><span class="nf">UA_NodeId_isNull</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/* Print the NodeId in the human-readable format defined in Part 6,</span>
<span class="cm"> * 5.3.1.10.</span>
<span class="cm"> *</span>
<span class="cm"> * Examples:</span>
<span class="cm"> *   UA_NODEID(&quot;i=13&quot;)</span>
<span class="cm"> *   UA_NODEID(&quot;ns=10;i=1&quot;)</span>
<span class="cm"> *   UA_NODEID(&quot;ns=10;s=Hello:World&quot;)</span>
<span class="cm"> *   UA_NODEID(&quot;g=09087e75-8e5e-499b-954f-f2a9603db28a&quot;)</span>
<span class="cm"> *   UA_NODEID(&quot;ns=1;b=b3BlbjYyNTQxIQ==&quot;) // base64</span>
<span class="cm"> *</span>
<span class="cm"> * The method can either use a pre-allocated string buffer or allocates memory</span>
<span class="cm"> * internally if called with an empty output string. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_NodeId_print</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">);</span>

<span class="cm">/* Parse the human-readable NodeId format. Attention! String and</span>
<span class="cm"> * ByteString NodeIds have their identifier malloc&#39;ed and need to be</span>
<span class="cm"> * cleaned up. */</span>
<span class="cp">#ifdef UA_ENABLE_PARSING</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_NodeId_parse</span><span class="p">(</span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_NodeId</span>
<span class="w">             </span><span class="n">UA_NODEID</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_NodeId_parse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">UA_STRING</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">chars</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>The following methods are a shorthand for creating NodeIds.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_NodeId</span>
<span class="w">             </span><span class="n">UA_NODEID_NUMERIC</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span>
<span class="w">                               </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">identifier</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">UA_NodeId</span><span class="p">));</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifierType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEIDTYPE_NUMERIC</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifier</span><span class="p">.</span><span class="n">numeric</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">identifier</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_NodeId</span>
<span class="w">             </span><span class="n">UA_NODEID_STRING</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">UA_NodeId</span><span class="p">));</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifierType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEIDTYPE_STRING</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifier</span><span class="p">.</span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_NodeId</span>
<span class="w">             </span><span class="n">UA_NODEID_STRING_ALLOC</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">UA_NodeId</span><span class="p">));</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifierType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEIDTYPE_STRING</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifier</span><span class="p">.</span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_ALLOC</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_NodeId</span>
<span class="w">             </span><span class="n">UA_NODEID_GUID</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Guid</span><span class="w"> </span><span class="n">guid</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">UA_NodeId</span><span class="p">));</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifierType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEIDTYPE_GUID</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifier</span><span class="p">.</span><span class="n">guid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">guid</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_NodeId</span>
<span class="w">             </span><span class="n">UA_NODEID_BYTESTRING</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">UA_NodeId</span><span class="p">));</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifierType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEIDTYPE_BYTESTRING</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifier</span><span class="p">.</span><span class="n">byteString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_BYTESTRING</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_NodeId</span>
<span class="w">             </span><span class="n">UA_NODEID_BYTESTRING_ALLOC</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">UA_NodeId</span><span class="p">));</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifierType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEIDTYPE_BYTESTRING</span><span class="p">;</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">identifier</span><span class="p">.</span><span class="n">byteString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_BYTESTRING_ALLOC</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="cm">/* Total ordering of NodeId */</span>
<span class="n">UA_Order</span>
<span class="n">UA_NodeId_order</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">n2</span><span class="p">);</span>

<span class="cm">/* Returns a non-cryptographic hash for NodeId */</span>
<span class="n">UA_UInt32</span><span class="w"> </span><span class="nf">UA_NodeId_hash</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="expandednodeid">
<span id="id4"></span><h3>ExpandedNodeId<a class="headerlink" href="#expandednodeid" title="Link to this heading">¶</a></h3>
<p>A NodeId that allows the namespace URI to be specified instead of an index.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">nodeId</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_String</span><span class="w"> </span><span class="n">namespaceUri</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">serverIndex</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="p">;</span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="n">UA_EXPANDEDNODEID_NULL</span><span class="p">;</span>

<span class="cm">/* Print the ExpandedNodeId in the humand-readable format defined in Part 6,</span>
<span class="cm"> * 5.3.1.11:</span>
<span class="cm"> *</span>
<span class="cm"> *   svr=&lt;serverindex&gt;;ns=&lt;namespaceindex&gt;;&lt;type&gt;=&lt;value&gt;</span>
<span class="cm"> *     or</span>
<span class="cm"> *   svr=&lt;serverindex&gt;;nsu=&lt;uri&gt;;&lt;type&gt;=&lt;value&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * The definitions for svr, ns and nsu is omitted if zero / the empty string.</span>
<span class="cm"> *</span>
<span class="cm"> * The method can either use a pre-allocated string buffer or allocates memory</span>
<span class="cm"> * internally if called with an empty output string. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_ExpandedNodeId_print</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">);</span>

<span class="cm">/* Parse the human-readable NodeId format. Attention! String and</span>
<span class="cm"> * ByteString NodeIds have their identifier malloc&#39;ed and need to be</span>
<span class="cm"> * cleaned up. */</span>
<span class="cp">#ifdef UA_ENABLE_PARSING</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_ExpandedNodeId_parse</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span>
<span class="w">             </span><span class="n">UA_EXPANDEDNODEID</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_ExpandedNodeId_parse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">UA_STRING</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">chars</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>The following functions are shorthand for creating ExpandedNodeIds.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span>
<span class="w">             </span><span class="n">UA_EXPANDEDNODEID_NUMERIC</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">identifier</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEID_NUMERIC</span><span class="p">(</span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="n">identifier</span><span class="p">);</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">serverIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceUri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_NULL</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span>
<span class="w">             </span><span class="n">UA_EXPANDEDNODEID_STRING</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEID_STRING</span><span class="p">(</span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">serverIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceUri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_NULL</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span>
<span class="w">             </span><span class="n">UA_EXPANDEDNODEID_STRING_ALLOC</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEID_STRING_ALLOC</span><span class="p">(</span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">serverIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceUri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_NULL</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span>
<span class="w">             </span><span class="n">UA_EXPANDEDNODEID_STRING_GUID</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Guid</span><span class="w"> </span><span class="n">guid</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEID_GUID</span><span class="p">(</span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="n">guid</span><span class="p">);</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">serverIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceUri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_NULL</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span>
<span class="w">             </span><span class="n">UA_EXPANDEDNODEID_BYTESTRING</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEID_BYTESTRING</span><span class="p">(</span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">serverIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceUri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_NULL</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span>
<span class="w">             </span><span class="n">UA_EXPANDEDNODEID_BYTESTRING_ALLOC</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_NODEID_BYTESTRING_ALLOC</span><span class="p">(</span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">serverIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">namespaceUri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_NULL</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span>
<span class="w">             </span><span class="n">UA_EXPANDEDNODEID_NODEID</span><span class="p">(</span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">nodeId</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">UA_ExpandedNodeId</span><span class="p">));</span>
<span class="w">    </span><span class="n">id</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodeId</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">})</span>

<span class="cm">/* Does the ExpandedNodeId point to a local node? That is, are namespaceUri and</span>
<span class="cm"> * serverIndex empty? */</span>
<span class="n">UA_Boolean</span>
<span class="n">UA_ExpandedNodeId_isLocal</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">n</span><span class="p">);</span>

<span class="cm">/* Total ordering of ExpandedNodeId */</span>
<span class="n">UA_Order</span>
<span class="nf">UA_ExpandedNodeId_order</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">n1</span><span class="p">,</span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">n2</span><span class="p">);</span>

<span class="cm">/* Returns a non-cryptographic hash for ExpandedNodeId. The hash of an</span>
<span class="cm"> * ExpandedNodeId is identical to the hash of the embedded (simple) NodeId if</span>
<span class="cm"> * the ServerIndex is zero and no NamespaceUri is set. */</span>
<span class="n">UA_UInt32</span>
<span class="nf">UA_ExpandedNodeId_hash</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ExpandedNodeId</span><span class="w"> </span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="qualifiedname">
<span id="id5"></span><h3>QualifiedName<a class="headerlink" href="#qualifiedname" title="Link to this heading">¶</a></h3>
<p>A name qualified by a namespace.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">namespaceIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_QualifiedName</span><span class="p">;</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_QualifiedName_isNull</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_QualifiedName</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">namespaceIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">})</span>

<span class="cm">/* Returns a non-cryptographic hash for QualifiedName */</span>
<span class="n">UA_UInt32</span>
<span class="n">UA_QualifiedName_hash</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_QualifiedName</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_QualifiedName</span>
<span class="w">             </span><span class="n">UA_QUALIFIEDNAME</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_QualifiedName</span><span class="w"> </span><span class="n">qn</span><span class="p">;</span>
<span class="w">    </span><span class="n">qn</span><span class="p">.</span><span class="n">namespaceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">qn</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">qn</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_QualifiedName</span>
<span class="w">             </span><span class="n">UA_QUALIFIEDNAME_ALLOC</span><span class="p">(</span><span class="n">UA_UInt16</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_QualifiedName</span><span class="w"> </span><span class="n">qn</span><span class="p">;</span>
<span class="w">    </span><span class="n">qn</span><span class="p">.</span><span class="n">namespaceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nsIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">qn</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_ALLOC</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">qn</span><span class="p">;</span>
<span class="p">})</span>
</pre></div>
</div>
</section>
<section id="localizedtext">
<h3>LocalizedText<a class="headerlink" href="#localizedtext" title="Link to this heading">¶</a></h3>
<p>Human readable text with an optional locale identifier.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_String</span><span class="w"> </span><span class="n">locale</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_String</span><span class="w"> </span><span class="n">text</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_LocalizedText</span><span class="p">;</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_LocalizedText</span>
<span class="w">             </span><span class="n">UA_LOCALIZEDTEXT</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">locale</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">text</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_LocalizedText</span><span class="w"> </span><span class="n">lt</span><span class="p">;</span>
<span class="w">    </span><span class="n">lt</span><span class="p">.</span><span class="n">locale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING</span><span class="p">(</span><span class="n">locale</span><span class="p">);</span>
<span class="w">    </span><span class="n">lt</span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lt</span><span class="p">;</span>
<span class="p">})</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_LocalizedText</span>
<span class="w">             </span><span class="n">UA_LOCALIZEDTEXT_ALLOC</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">locale</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">text</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_LocalizedText</span><span class="w"> </span><span class="n">lt</span><span class="p">;</span>
<span class="w">    </span><span class="n">lt</span><span class="p">.</span><span class="n">locale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_ALLOC</span><span class="p">(</span><span class="n">locale</span><span class="p">);</span>
<span class="w">    </span><span class="n">lt</span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UA_STRING_ALLOC</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lt</span><span class="p">;</span>
<span class="p">})</span>
</pre></div>
</div>
</section>
<section id="numericrange">
<span id="id6"></span><h3>NumericRange<a class="headerlink" href="#numericrange" title="Link to this heading">¶</a></h3>
<p>NumericRanges are used to indicate subsets of a (multidimensional) array.
They no official data type in the OPC UA standard and are transmitted only
with a string encoding, such as “1:2,0:3,5”. The colon separates min/max
index and the comma separates dimensions. A single value indicates a range
with a single element (min==max).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">min</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">max</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_NumericRangeDimension</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">dimensionsSize</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_NumericRangeDimension</span><span class="w"> </span><span class="o">*</span><span class="n">dimensions</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="p">;</span>

<span class="n">UA_StatusCode</span>
<span class="nf">UA_NumericRange_parse</span><span class="p">(</span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="o">*</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>

<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_NumericRange</span>
<span class="w">             </span><span class="n">UA_NUMERICRANGE</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="n">nr</span><span class="p">;</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">nr</span><span class="p">));</span>
<span class="w">    </span><span class="n">UA_NumericRange_parse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span><span class="w"> </span><span class="n">UA_STRING</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">s</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">nr</span><span class="p">;</span>
<span class="p">})</span>
</pre></div>
</div>
</section>
<section id="variant">
<span id="id7"></span><h3>Variant<a class="headerlink" href="#variant" title="Link to this heading">¶</a></h3>
<p>Variants may contain values of any type together with a description of the
content. See the section on <a class="reference internal" href="#generic-types"><span class="std std-ref">Generic Type Handling</span></a> on how types are described.
The standard mandates that variants contain built-in data types only. If the
value is not of a builtin type, it is wrapped into an <a class="reference internal" href="#extensionobject"><span class="std std-ref">ExtensionObject</span></a>.
open62541 hides this wrapping transparently in the encoding layer. If the
data type is unknown to the receiver, the variant contains the original
ExtensionObject in binary or XML encoding.</p>
<p>Variants may contain a scalar value or an array. For details on the handling
of arrays, see the section on <a class="reference internal" href="#array-handling"><span class="std std-ref">Array handling</span></a>. Array variants can have
an additional dimensionality (matrix, 3-tensor, …) defined in an array of
dimension lengths. The actual values are kept in an array of dimensions one.
For users who work with higher-dimensions arrays directly, keep in mind that
dimensions of higher rank are serialized first (the highest rank dimension
has stride 1 and elements follow each other directly). Usually it is simplest
to interact with higher-dimensional arrays via <code class="docutils literal notranslate"><span class="pre">UA_NumericRange</span></code>
descriptions (see <a class="reference internal" href="#array-handling"><span class="std std-ref">Array handling</span></a>).</p>
<p>To differentiate between scalar / array variants, the following definition is
used. <code class="docutils literal notranslate"><span class="pre">UA_Variant_isScalar</span></code> provides simplified access to these checks.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">arrayLength</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">data</span> <span class="pre">==</span> <span class="pre">NULL</span></code>: undefined array of length -1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arrayLength</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">data</span> <span class="pre">==</span> <span class="pre">UA_EMPTY_ARRAY_SENTINEL</span></code>: array of length 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arrayLength</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">data</span> <span class="pre">&gt;</span> <span class="pre">UA_EMPTY_ARRAY_SENTINEL</span></code>: scalar value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arrayLength</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>: array of the given length</p></li>
</ul>
<p>Variants can also be <em>empty</em>. Then, the pointer to the type description is
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Forward declaration. See the section on Generic Type Handling */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">UA_DataType</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_DataType</span><span class="w"> </span><span class="n">UA_DataType</span><span class="p">;</span>

<span class="cp">#define UA_EMPTY_ARRAY_SENTINEL ((void*)0x01)</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_VARIANT_DATA</span><span class="p">,</span><span class="w">         </span><span class="cm">/* The data has the same lifecycle as the variant */</span>
<span class="w">    </span><span class="n">UA_VARIANT_DATA_NODELETE</span><span class="w"> </span><span class="cm">/* The data is &quot;borrowed&quot; by the variant and is</span>
<span class="cm">                              * not deleted when the variant is cleared up.</span>
<span class="cm">                              * The array dimensions also borrowed. */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_VariantStorageType</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">;</span><span class="w">      </span><span class="cm">/* The data type description */</span>
<span class="w">    </span><span class="n">UA_VariantStorageType</span><span class="w"> </span><span class="n">storageType</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">;</span><span class="w">           </span><span class="cm">/* The number of elements in the data array */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* Points to the scalar or array data */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">arrayDimensionsSize</span><span class="p">;</span><span class="w">   </span><span class="cm">/* The number of dimensions */</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="o">*</span><span class="n">arrayDimensions</span><span class="p">;</span><span class="w">   </span><span class="cm">/* The length of each dimension */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_Variant</span><span class="p">;</span>

<span class="cm">/* Returns true if the variant has no value defined (contains neither an array</span>
<span class="cm"> * nor a scalar value).</span>
<span class="cm"> *</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @return Is the variant empty */</span>
<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_Variant_isEmpty</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">})</span>

<span class="cm">/* Returns true if the variant contains a scalar value. Note that empty variants</span>
<span class="cm"> * contain an array of length -1 (undefined).</span>
<span class="cm"> *</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @return Does the variant contain a scalar value */</span>
<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_Variant_isScalar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">arrayLength</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">UA_EMPTY_ARRAY_SENTINEL</span><span class="p">);</span>
<span class="p">})</span>

<span class="cm">/* Returns true if the variant contains a scalar value of the given type.</span>
<span class="cm"> *</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @param type The data type</span>
<span class="cm"> * @return Does the variant contain a scalar value of the given type */</span>
<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_Variant_hasScalarType</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">UA_Variant_isScalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
<span class="p">})</span>

<span class="cm">/* Returns true if the variant contains an array of the given type.</span>
<span class="cm"> *</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @param type The data type</span>
<span class="cm"> * @return Does the variant contain an array of the given type */</span>
<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_Variant_hasArrayType</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">,</span>
<span class="w">                                     </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">UA_Variant_isScalar</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
<span class="p">})</span>

<span class="cm">/* Set the variant to a scalar value that already resides in memory. The value</span>
<span class="cm"> * takes on the lifecycle of the variant and is deleted with it.</span>
<span class="cm"> *</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @param p A pointer to the value data</span>
<span class="cm"> * @param type The datatype of the value in question */</span>
<span class="kt">void</span>
<span class="n">UA_Variant_setScalar</span><span class="p">(</span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Set the variant to a scalar value that is copied from an existing variable.</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @param p A pointer to the value data</span>
<span class="cm"> * @param type The datatype of the value</span>
<span class="cm"> * @return Indicates whether the operation succeeded or returns an error code */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Variant_setScalarCopy</span><span class="p">(</span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Set the variant to an array that already resides in memory. The array takes</span>
<span class="cm"> * on the lifecycle of the variant and is deleted with it.</span>
<span class="cm"> *</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @param array A pointer to the array data</span>
<span class="cm"> * @param arraySize The size of the array</span>
<span class="cm"> * @param type The datatype of the array */</span>
<span class="kt">void</span>
<span class="nf">UA_Variant_setArray</span><span class="p">(</span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">arraySize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Set the variant to an array that is copied from an existing array.</span>
<span class="cm"> *</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @param array A pointer to the array data</span>
<span class="cm"> * @param arraySize The size of the array</span>
<span class="cm"> * @param type The datatype of the array</span>
<span class="cm"> * @return Indicates whether the operation succeeded or returns an error code */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Variant_setArrayCopy</span><span class="p">(</span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">arraySize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Copy the variant, but use only a subset of the (multidimensional) array into</span>
<span class="cm"> * a variant. Returns an error code if the variant is not an array or if the</span>
<span class="cm"> * indicated range does not fit.</span>
<span class="cm"> *</span>
<span class="cm"> * @param src The source variant</span>
<span class="cm"> * @param dst The target variant</span>
<span class="cm"> * @param range The range of the copied data</span>
<span class="cm"> * @return Returns UA_STATUSCODE_GOOD or an error code */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Variant_copyRange</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="n">range</span><span class="p">);</span>

<span class="cm">/* Insert a range of data into an existing variant. The data array cannot be</span>
<span class="cm"> * reused afterwards if it contains types without a fixed size (e.g. strings)</span>
<span class="cm"> * since the members are moved into the variant and take on its lifecycle.</span>
<span class="cm"> *</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @param dataArray The data array. The type must match the variant</span>
<span class="cm"> * @param dataArraySize The length of the data array. This is checked to match</span>
<span class="cm"> *        the range size.</span>
<span class="cm"> * @param range The range of where the new data is inserted</span>
<span class="cm"> * @return Returns UA_STATUSCODE_GOOD or an error code */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Variant_setRange</span><span class="p">(</span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">arraySize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="n">range</span><span class="p">);</span>

<span class="cm">/* Deep-copy a range of data into an existing variant.</span>
<span class="cm"> *</span>
<span class="cm"> * @param v The variant</span>
<span class="cm"> * @param dataArray The data array. The type must match the variant</span>
<span class="cm"> * @param dataArraySize The length of the data array. This is checked to match</span>
<span class="cm"> *        the range size.</span>
<span class="cm"> * @param range The range of where the new data is inserted</span>
<span class="cm"> * @return Returns UA_STATUSCODE_GOOD or an error code */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Variant_setRangeCopy</span><span class="p">(</span><span class="n">UA_Variant</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">arraySize</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="n">range</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="extensionobject">
<span id="id8"></span><h3>ExtensionObject<a class="headerlink" href="#extensionobject" title="Link to this heading">¶</a></h3>
<p>ExtensionObjects may contain scalars of any data type. Even those that are
unknown to the receiver. See the section on <a class="reference internal" href="#generic-types"><span class="std std-ref">Generic Type Handling</span></a> on how types
are described. If the received data type is unknown, the encoded string and
target NodeId is stored instead of the decoded value.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_EXTENSIONOBJECT_ENCODED_NOBODY</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_EXTENSIONOBJECT_ENCODED_BYTESTRING</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_EXTENSIONOBJECT_ENCODED_XML</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_EXTENSIONOBJECT_DECODED</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_EXTENSIONOBJECT_DECODED_NODELETE</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="cm">/* Don&#39;t delete the content</span>
<span class="cm">                                                 together with the</span>
<span class="cm">                                                 ExtensionObject */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ExtensionObjectEncoding</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_ExtensionObjectEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p">;</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">typeId</span><span class="p">;</span><span class="w">   </span><span class="cm">/* The nodeid of the datatype */</span>
<span class="w">            </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="n">body</span><span class="p">;</span><span class="w"> </span><span class="cm">/* The bytestring of the encoded data */</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">encoded</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">;</span>
<span class="w">            </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">decoded</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">content</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_ExtensionObject</span><span class="p">;</span>

<span class="cm">/* Initialize the ExtensionObject and set the &quot;decoded&quot; value to the given</span>
<span class="cm"> * pointer. The value will be deleted when the ExtensionObject is cleared. */</span>
<span class="kt">void</span>
<span class="nf">UA_ExtensionObject_setValue</span><span class="p">(</span><span class="n">UA_ExtensionObject</span><span class="w"> </span><span class="o">*</span><span class="n">eo</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Initialize the ExtensionObject and set the &quot;decoded&quot; value to the given</span>
<span class="cm"> * pointer. The value will *not* be deleted when the ExtensionObject is</span>
<span class="cm"> * cleared. */</span>
<span class="kt">void</span>
<span class="nf">UA_ExtensionObject_setValueNoDelete</span><span class="p">(</span><span class="n">UA_ExtensionObject</span><span class="w"> </span><span class="o">*</span><span class="n">eo</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Initialize the ExtensionObject and set the &quot;decoded&quot; value to a fresh copy of</span>
<span class="cm"> * the given value pointer. The value will be deleted when the ExtensionObject</span>
<span class="cm"> * is cleared. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_ExtensionObject_setValueCopy</span><span class="p">(</span><span class="n">UA_ExtensionObject</span><span class="w"> </span><span class="o">*</span><span class="n">eo</span><span class="p">,</span>
<span class="w">                                </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="datavalue">
<span id="id9"></span><h3>DataValue<a class="headerlink" href="#datavalue" title="Link to this heading">¶</a></h3>
<p>A data value with an associated status code and timestamps.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_Variant</span><span class="w">    </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_DateTime</span><span class="w">   </span><span class="n">sourceTimestamp</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_DateTime</span><span class="w">   </span><span class="n">serverTimestamp</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w">     </span><span class="n">sourcePicoseconds</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_UInt16</span><span class="w">     </span><span class="n">serverPicoseconds</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasValue</span><span class="w">             </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasStatus</span><span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasSourceTimestamp</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasServerTimestamp</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasSourcePicoseconds</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasServerPicoseconds</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DataValue</span><span class="p">;</span>

<span class="cm">/* Copy the DataValue, but use only a subset of the (multidimensional) array of</span>
<span class="cm"> * of the variant of the source DataValue. Returns an error code if the variant</span>
<span class="cm"> * of the DataValue is not an array or if the indicated range does not fit.</span>
<span class="cm"> *</span>
<span class="cm"> * @param src The source DataValue</span>
<span class="cm"> * @param dst The target DataValue</span>
<span class="cm"> * @param range The range of the variant of the DataValue to copy</span>
<span class="cm"> * @return Returns UA_STATUSCODE_GOOD or an error code */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_DataValue_copyVariantRange</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataValue</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">UA_DataValue</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span>
<span class="w">                              </span><span class="k">const</span><span class="w"> </span><span class="n">UA_NumericRange</span><span class="w"> </span><span class="n">range</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="diagnosticinfo">
<h3>DiagnosticInfo<a class="headerlink" href="#diagnosticinfo" title="Link to this heading">¶</a></h3>
<p>A structure that contains detailed error and diagnostic information
associated with a StatusCode.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_DiagnosticInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasSymbolicId</span><span class="w">          </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasNamespaceUri</span><span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasLocalizedText</span><span class="w">       </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasLocale</span><span class="w">              </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasAdditionalInfo</span><span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasInnerStatusCode</span><span class="w">     </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w">    </span><span class="n">hasInnerDiagnosticInfo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Int32</span><span class="w">      </span><span class="n">symbolicId</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Int32</span><span class="w">      </span><span class="n">namespaceUri</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Int32</span><span class="w">      </span><span class="n">localizedText</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Int32</span><span class="w">      </span><span class="n">locale</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_String</span><span class="w">     </span><span class="n">additionalInfo</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_StatusCode</span><span class="w"> </span><span class="n">innerStatusCode</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_DiagnosticInfo</span><span class="w"> </span><span class="o">*</span><span class="n">innerDiagnosticInfo</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DiagnosticInfo</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="generic-type-handling">
<span id="generic-types"></span><h2>Generic Type Handling<a class="headerlink" href="#generic-type-handling" title="Link to this heading">¶</a></h2>
<p>All information about a (builtin/structured) data type is stored in a
<code class="docutils literal notranslate"><span class="pre">UA_DataType</span></code>. The array <code class="docutils literal notranslate"><span class="pre">UA_TYPES</span></code> contains the description of all
standard-defined types. This type description is used for the following
generic operations that work on all types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">T_init(T</span> <span class="pre">*ptr)</span></code>: Initialize the data type. This is synonymous with
zeroing out the memory, i.e. <code class="docutils literal notranslate"><span class="pre">memset(ptr,</span> <span class="pre">0,</span> <span class="pre">sizeof(T))</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T*</span> <span class="pre">T_new()</span></code>: Allocate and return the memory for the data type. The
value is already initialized.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UA_StatusCode</span> <span class="pre">T_copy(const</span> <span class="pre">T</span> <span class="pre">*src,</span> <span class="pre">T</span> <span class="pre">*dst)</span></code>: Copy the content of the
data type. Returns <code class="docutils literal notranslate"><span class="pre">UA_STATUSCODE_GOOD</span></code> or
<code class="docutils literal notranslate"><span class="pre">UA_STATUSCODE_BADOUTOFMEMORY</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">T_clear(T</span> <span class="pre">*ptr)</span></code>: Delete the dynamically allocated content
of the data type and perform a <code class="docutils literal notranslate"><span class="pre">T_init</span></code> to reset the type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">T_delete(T</span> <span class="pre">*ptr)</span></code>: Delete the content of the data type and the
memory for the data type itself.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">T_equal(T</span> <span class="pre">*p1,</span> <span class="pre">T</span> <span class="pre">*p2)</span></code>: Compare whether <code class="docutils literal notranslate"><span class="pre">p1</span></code> and <code class="docutils literal notranslate"><span class="pre">p2</span></code> have
identical content. You can use <code class="docutils literal notranslate"><span class="pre">UA_order</span></code> if an absolute ordering
is required.</p></li>
</ul>
<p>Specializations, such as <code class="docutils literal notranslate"><span class="pre">UA_Int32_new()</span></code> are derived from the generic
type operations as static inline functions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifdef UA_ENABLE_TYPEDESCRIPTION</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">memberName</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Human-readable member name */</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">memberType</span><span class="p">;</span><span class="cm">/* The member data type description */</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">padding</span><span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w">       </span><span class="cm">/* How much padding is there before this</span>
<span class="cm">                                     member element? For arrays this is the</span>
<span class="cm">                                     padding before the size_t length member.</span>
<span class="cm">                                     (No padding between size_t and the</span>
<span class="cm">                                     following ptr.) For unions, the padding</span>
<span class="cm">                                     includes the size of the switchfield (the</span>
<span class="cm">                                     offset from the start of the union</span>
<span class="cm">                                     type). */</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">isArray</span><span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">       </span><span class="cm">/* The member is an array */</span>
<span class="w">    </span><span class="n">UA_Byte</span><span class="w"> </span><span class="n">isOptional</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">       </span><span class="cm">/* The member is an optional field */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DataTypeMember</span><span class="p">;</span>

<span class="cm">/* The DataType &quot;kind&quot; is an internal type classification. It is used to</span>
<span class="cm"> * dispatch handling to the correct routines. */</span>
<span class="cp">#define UA_DATATYPEKINDS 31</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_BOOLEAN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_SBYTE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_BYTE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_INT16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_UINT16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_INT32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_UINT32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_INT64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_UINT64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_FLOAT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_DOUBLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_STRING</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_DATETIME</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_GUID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_BYTESTRING</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_XMLELEMENT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_NODEID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_EXPANDEDNODEID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_STATUSCODE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_QUALIFIEDNAME</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_LOCALIZEDTEXT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_EXTENSIONOBJECT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_DATAVALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_VARIANT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_DIAGNOSTICINFO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">24</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_DECIMAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_ENUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">26</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_STRUCTURE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_OPTSTRUCT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">28</span><span class="p">,</span><span class="w"> </span><span class="cm">/* struct with optional fields */</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_UNION</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">29</span><span class="p">,</span>
<span class="w">    </span><span class="n">UA_DATATYPEKIND_BITFIELDCLUSTER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="cm">/* bitfields + padding */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DataTypeKind</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">UA_DataType</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifdef UA_ENABLE_TYPEDESCRIPTION</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">typeName</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">typeId</span><span class="p">;</span><span class="w">           </span><span class="cm">/* The nodeid of the type */</span>
<span class="w">    </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="n">binaryEncodingId</span><span class="p">;</span><span class="w"> </span><span class="cm">/* NodeId of datatype when encoded as binary */</span>
<span class="w">    </span><span class="c1">//UA_NodeId xmlEncodingId;  /* NodeId of datatype when encoded as XML */</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">memSize</span><span class="w">     </span><span class="o">:</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Size of the struct in memory */</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">typeKind</span><span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Dispatch index for the handling routines */</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">pointerFree</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="cm">/* The type (and its members) contains no</span>
<span class="cm">                                 * pointers that need to be freed */</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">overlayable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="cm">/* The type has the identical memory layout</span>
<span class="cm">                                 * in memory and on the binary stream. */</span>
<span class="w">    </span><span class="n">UA_UInt32</span><span class="w"> </span><span class="n">membersSize</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="cm">/* How many members does the type have? */</span>
<span class="w">    </span><span class="n">UA_DataTypeMember</span><span class="w"> </span><span class="o">*</span><span class="n">members</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Datatype arrays with custom type definitions can be added in a linked list to</span>
<span class="cm"> * the client or server configuration. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_DataTypeArray</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">UA_DataTypeArray</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">typesSize</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">types</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">cleanup</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Free the array structure and its content</span>
<span class="cm">                           when the client or server configuration</span>
<span class="cm">                           containing it is cleaned up */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DataTypeArray</span><span class="p">;</span>

<span class="cm">/* Returns the offset and type of a structure member. The return value is false</span>
<span class="cm"> * if the member was not found.</span>
<span class="cm"> *</span>
<span class="cm"> * If the member is an array, the offset points to the (size_t) length field.</span>
<span class="cm"> * (The array pointer comes after the length field without any padding.) */</span>
<span class="cp">#ifdef UA_ENABLE_TYPEDESCRIPTION</span>
<span class="n">UA_Boolean</span>
<span class="nf">UA_DataType_getStructMember</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">memberName</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">outOffset</span><span class="p">,</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">**</span><span class="n">outMemberType</span><span class="p">,</span>
<span class="w">                            </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="o">*</span><span class="n">outIsArray</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Test if the data type is a numeric builtin data type (via the typeKind field</span>
<span class="cm"> * of UA_DataType). This includes integers and floating point numbers. Not</span>
<span class="cm"> * included are Boolean, DateTime, StatusCode and Enums. */</span>
<span class="n">UA_Boolean</span>
<span class="nf">UA_DataType_isNumeric</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
<p>Builtin data types can be accessed as UA_TYPES[UA_TYPES_XXX], where XXX is
the name of the data type. If only the NodeId of a type is known, use the
following method to retrieve the data type description.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Returns the data type description for the type&#39;s identifier or NULL if no</span>
<span class="cm"> * matching data type was found. */</span>
<span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span>
<span class="nf">UA_findDataType</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">typeId</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Add custom data types to the search scope of UA_findDataType. */</span>

<span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span>
<span class="nf">UA_findDataTypeWithCustom</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_NodeId</span><span class="w"> </span><span class="o">*</span><span class="n">typeId</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataTypeArray</span><span class="w"> </span><span class="o">*</span><span class="n">customTypes</span><span class="p">);</span>
</pre></div>
</div>
<p>The following functions are used for generic handling of data types.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Allocates and initializes a variable of type dataType</span>
<span class="cm"> *</span>
<span class="cm"> * @param type The datatype description</span>
<span class="cm"> * @return Returns the memory location of the variable or NULL if no</span>
<span class="cm"> *         memory could be allocated */</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">UA_new</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Initializes a variable to default values</span>
<span class="cm"> *</span>
<span class="cm"> * @param p The memory location of the variable</span>
<span class="cm"> * @param type The datatype description */</span>
<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="kt">void</span>
<span class="w">             </span><span class="n">UA_init</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="o">-&gt;</span><span class="n">memSize</span><span class="p">);</span>
<span class="p">})</span>

<span class="cm">/* Copies the content of two variables. If copying fails (e.g. because no memory</span>
<span class="cm"> * was available for an array), then dst is emptied and initialized to prevent</span>
<span class="cm"> * memory leaks.</span>
<span class="cm"> *</span>
<span class="cm"> * @param src The memory location of the source variable</span>
<span class="cm"> * @param dst The memory location of the destination variable</span>
<span class="cm"> * @param type The datatype description</span>
<span class="cm"> * @return Indicates whether the operation succeeded or returns an error code */</span>
<span class="n">UA_StatusCode</span>
<span class="n">UA_copy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Deletes the dynamically allocated content of a variable (e.g. resets all</span>
<span class="cm"> * arrays to undefined arrays). Afterwards, the variable can be safely deleted</span>
<span class="cm"> * without causing memory leaks. But the variable is not initialized and may</span>
<span class="cm"> * contain old data that is not memory-relevant.</span>
<span class="cm"> *</span>
<span class="cm"> * @param p The memory location of the variable</span>
<span class="cm"> * @param type The datatype description of the variable */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">UA_clear</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cp">#define UA_deleteMembers(p, type) UA_clear(p, type)</span>

<span class="cm">/* Frees a variable and all of its content.</span>
<span class="cm"> *</span>
<span class="cm"> * @param p The memory location of the variable</span>
<span class="cm"> * @param type The datatype description of the variable */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">UA_delete</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Pretty-print the value from the datatype. The output is pretty-printed JSON5.</span>
<span class="cm"> * Note that this format is non-standard and should not be sent over the</span>
<span class="cm"> * network. It can however be read by our own JSON decoding.</span>
<span class="cm"> *</span>
<span class="cm"> * @param p The memory location of the variable</span>
<span class="cm"> * @param type The datatype description of the variable</span>
<span class="cm"> * @param output A string that is used for the pretty-printed output. If the</span>
<span class="cm"> *        memory for string is already allocated, we try to use the existing</span>
<span class="cm"> *        string (the length is adjusted). If the string is empty, memory</span>
<span class="cm"> *        is allocated for it.</span>
<span class="cm"> * @return Indicates whether the operation succeeded */</span>
<span class="cp">#ifdef UA_ENABLE_JSON_ENCODING</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_print</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Compare two values and return their order.</span>
<span class="cm"> *</span>
<span class="cm"> * For numerical types (including StatusCodes and Enums), their natural order is</span>
<span class="cm"> * used. NaN is the &quot;smallest&quot; value for floating point values. Different bit</span>
<span class="cm"> * representations of NaN are considered identical.</span>
<span class="cm"> *</span>
<span class="cm"> * All other types have *some* absolute ordering so that a &lt; b, b &lt; c -&gt; a &lt; c.</span>
<span class="cm"> *</span>
<span class="cm"> * The ordering of arrays (also strings) is in &quot;shortlex&quot;: A shorter array is</span>
<span class="cm"> * always smaller than a longer array. Otherwise the first different element</span>
<span class="cm"> * defines the order.</span>
<span class="cm"> *</span>
<span class="cm"> * When members of different types are permitted (in Variants and</span>
<span class="cm"> * ExtensionObjects), the memory address in the &quot;UA_DataType*&quot; pointer</span>
<span class="cm"> * determines which variable is smaller.</span>
<span class="cm"> *</span>
<span class="cm"> * @param p1 The memory location of the first value</span>
<span class="cm"> * @param p2 The memory location of the first value</span>
<span class="cm"> * @param type The datatype description of both values */</span>
<span class="n">UA_Order</span>
<span class="nf">UA_order</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Compare if two values have identical content. */</span>
<span class="n">UA_INLINABLE</span><span class="p">(</span><span class="n">UA_Boolean</span>
<span class="w">             </span><span class="n">UA_equal</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">),</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">UA_order</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">UA_ORDER_EQ</span><span class="p">);</span>
<span class="p">})</span>
</pre></div>
</div>
</section>
<section id="binary-encoding-decoding">
<h2>Binary Encoding/Decoding<a class="headerlink" href="#binary-encoding-decoding" title="Link to this heading">¶</a></h2>
<p>Encoding and decoding routines for the binary format. For the binary decoding
additional data types can be forwarded.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Returns the number of bytes the value p takes in binary encoding. Returns</span>
<span class="cm"> * zero if an error occurs. */</span>
<span class="kt">size_t</span>
<span class="nf">UA_calcSizeBinary</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Encodes a data-structure in the binary format. If outBuf has a length of</span>
<span class="cm"> * zero, a buffer of the required size is allocated. Otherwise, encoding into</span>
<span class="cm"> * the existing outBuf is attempted (and may fail if the buffer is too</span>
<span class="cm"> * small). */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_encodeBinary</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="w">                </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="o">*</span><span class="n">outBuf</span><span class="p">);</span>

<span class="cm">/* The structure with the decoding options may be extended in the future.</span>
<span class="cm"> * Zero-out the entire structure initially to ensure code-compatibility when</span>
<span class="cm"> * more fields are added in a later release. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataTypeArray</span><span class="w"> </span><span class="o">*</span><span class="n">customTypes</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Begin of a linked list with custom</span>
<span class="cm">                                          * datatype definitions */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DecodeBinaryOptions</span><span class="p">;</span>

<span class="cm">/* Decodes a data structure from the input buffer in the binary format. It is</span>
<span class="cm"> * assumed that `p` points to valid memory (not necessarily zeroed out). The</span>
<span class="cm"> * options can be NULL and will be disregarded in that case. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_decodeBinary</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="o">*</span><span class="n">inBuf</span><span class="p">,</span>
<span class="w">                </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DecodeBinaryOptions</span><span class="w"> </span><span class="o">*</span><span class="n">options</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="json-en-decoding">
<h2>JSON En/Decoding<a class="headerlink" href="#json-en-decoding" title="Link to this heading">¶</a></h2>
<p>The JSON decoding can parse the official encoding from the OPC UA
specification. It further allows the following extensions:</p>
<ul class="simple">
<li><p>The strict JSON format is relaxed to also allow the JSON5 extensions
(<a class="reference external" href="https://json5.org/">https://json5.org/</a>). This allows for more human-readable encoding and adds
convenience features such as trailing commas in arrays and comments within
JSON documents.</p></li>
<li><p>Int64/UInt64 don’t necessarily have to be wrapped into a string.</p></li>
<li><p>If <cite>UA_ENABLE_PARSING</cite> is set, NodeIds and ExpandedNodeIds can be given in
the string encoding (e.g. “ns=1;i=42”, see <cite>UA_NodeId_parse</cite>). The standard
encoding is to express NodeIds as JSON objects.</p></li>
</ul>
<p>These extensions are not intended to be used for the OPC UA protocol on the
network. They were rather added to allow more convenient configuration file
formats that also include data in the OPC UA type system.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef UA_ENABLE_JSON_ENCODING</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">namespaces</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">namespacesSize</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">serverUris</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">serverUrisSize</span><span class="p">;</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">useReversible</span><span class="p">;</span>

<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">prettyPrint</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Add newlines and spaces for legibility */</span>

<span class="w">    </span><span class="cm">/* Enabling the following options leads to non-standard compatible JSON5</span>
<span class="cm">     * encoding! Use it for pretty-printing, but not for sending messages over</span>
<span class="cm">     * the network. (Our own decoding can still parse it.) */</span>

<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">unquotedKeys</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Don&#39;t print quotes around object element keys */</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">stringNodeIds</span><span class="p">;</span><span class="w"> </span><span class="cm">/* String encoding for NodeIds, like &quot;ns=1;i=42&quot; */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_EncodeJsonOptions</span><span class="p">;</span>

<span class="cm">/* Returns the number of bytes the value src takes in json encoding. Returns</span>
<span class="cm"> * zero if an error occurs. */</span>
<span class="kt">size_t</span>
<span class="nf">UA_calcSizeJson</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">UA_EncodeJsonOptions</span><span class="w"> </span><span class="o">*</span><span class="n">options</span><span class="p">);</span>

<span class="cm">/* Encodes the scalar value described by type to json encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * @param src The value. Must not be NULL.</span>
<span class="cm"> * @param type The value type. Must not be NULL.</span>
<span class="cm"> * @param outBuf Pointer to ByteString containing the result if the encoding</span>
<span class="cm"> *        was successful</span>
<span class="cm"> * @return Returns a statuscode whether encoding succeeded. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_encodeJson</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="o">*</span><span class="n">outBuf</span><span class="p">,</span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="n">UA_EncodeJsonOptions</span><span class="w"> </span><span class="o">*</span><span class="n">options</span><span class="p">);</span>

<span class="cm">/* The structure with the decoding options may be extended in the future.</span>
<span class="cm"> * Zero-out the entire structure initially to ensure code-compatibility when</span>
<span class="cm"> * more fields are added in a later release. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">namespaces</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">namespacesSize</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_String</span><span class="w"> </span><span class="o">*</span><span class="n">serverUris</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">serverUrisSize</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataTypeArray</span><span class="w"> </span><span class="o">*</span><span class="n">customTypes</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Begin of a linked list with custom</span>
<span class="cm">                                          * datatype definitions */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DecodeJsonOptions</span><span class="p">;</span>

<span class="cm">/* Decodes a scalar value described by type from json encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * @param src The buffer with the json encoded value. Must not be NULL.</span>
<span class="cm"> * @param dst The target value. Must not be NULL. The target is assumed to have</span>
<span class="cm"> *        size type-&gt;memSize. The value is reset to zero before decoding. If</span>
<span class="cm"> *        decoding fails, members are deleted and the value is reset (zeroed)</span>
<span class="cm"> *        again.</span>
<span class="cm"> * @param type The value type. Must not be NULL.</span>
<span class="cm"> * @param options The options struct for decoding, currently unused</span>
<span class="cm"> * @return Returns a statuscode whether decoding succeeded. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_decodeJson</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DecodeJsonOptions</span><span class="w"> </span><span class="o">*</span><span class="n">options</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* UA_ENABLE_JSON_ENCODING */</span>
</pre></div>
</div>
</section>
<section id="xml-en-decoding">
<h2>XML En/Decoding<a class="headerlink" href="#xml-en-decoding" title="Link to this heading">¶</a></h2>
<p>The XML decoding can parse the official encoding from the OPC UA
specification.</p>
<p>These extensions are not intended to be used for the OPC UA protocol on the
network. They were rather added to allow more convenient configuration file
formats that also include data in the OPC UA type system.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef UA_ENABLE_XML_ENCODING</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UA_Boolean</span><span class="w"> </span><span class="n">prettyPrint</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Add newlines and spaces for legibility */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_EncodeXmlOptions</span><span class="p">;</span>

<span class="cm">/* Returns the number of bytes the value src takes in xml encoding. Returns</span>
<span class="cm"> * zero if an error occurs. */</span>
<span class="kt">size_t</span>
<span class="nf">UA_calcSizeXml</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="n">UA_EncodeXmlOptions</span><span class="w"> </span><span class="o">*</span><span class="n">options</span><span class="p">);</span>

<span class="cm">/* Encodes the scalar value described by type to xml encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * @param src The value. Must not be NULL.</span>
<span class="cm"> * @param type The value type. Must not be NULL.</span>
<span class="cm"> * @param outBuf Pointer to ByteString containing the result if the encoding</span>
<span class="cm"> *        was successful</span>
<span class="cm"> * @return Returns a statuscode whether encoding succeeded. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_encodeXml</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="o">*</span><span class="n">outBuf</span><span class="p">,</span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">UA_EncodeXmlOptions</span><span class="w"> </span><span class="o">*</span><span class="n">options</span><span class="p">);</span>

<span class="cm">/* The structure with the decoding options may be extended in the future.</span>
<span class="cm"> * Zero-out the entire structure initially to ensure code-compatibility when</span>
<span class="cm"> * more fields are added in a later release. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataTypeArray</span><span class="w"> </span><span class="o">*</span><span class="n">customTypes</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Begin of a linked list with custom</span>
<span class="cm">                                          * datatype definitions */</span>
<span class="p">}</span><span class="w"> </span><span class="n">UA_DecodeXmlOptions</span><span class="p">;</span>

<span class="cm">/* Decodes a scalar value described by type from xml encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * @param src The buffer with the xml encoded value. Must not be NULL.</span>
<span class="cm"> * @param dst The target value. Must not be NULL. The target is assumed to have</span>
<span class="cm"> *        size type-&gt;memSize. The value is reset to zero before decoding. If</span>
<span class="cm"> *        decoding fails, members are deleted and the value is reset (zeroed)</span>
<span class="cm"> *        again.</span>
<span class="cm"> * @param type The value type. Must not be NULL.</span>
<span class="cm"> * @param options The options struct for decoding, currently unused</span>
<span class="cm"> * @return Returns a statuscode whether decoding succeeded. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_decodeXml</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UA_ByteString</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DecodeXmlOptions</span><span class="w"> </span><span class="o">*</span><span class="n">options</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* UA_ENABLE_XML_ENCODING */</span>
</pre></div>
</div>
</section>
<section id="array-handling">
<span id="id10"></span><h2>Array handling<a class="headerlink" href="#array-handling" title="Link to this heading">¶</a></h2>
<p>In OPC UA, arrays can have a length of zero or more with the usual meaning.
In addition, arrays can be undefined. Then, they don’t even have a length. In
the binary encoding, this is indicated by an array of length -1.</p>
<p>In open62541 however, we use <code class="docutils literal notranslate"><span class="pre">size_t</span></code> for array lengths. An undefined array
has length 0 and the data pointer is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. An array of length 0 also has
length 0 but a data pointer <code class="docutils literal notranslate"><span class="pre">UA_EMPTY_ARRAY_SENTINEL</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Allocates and initializes an array of variables of a specific type</span>
<span class="cm"> *</span>
<span class="cm"> * @param size The requested array length</span>
<span class="cm"> * @param type The datatype description</span>
<span class="cm"> * @return Returns the memory location of the variable or NULL if no memory</span>
<span class="cm"> *         could be allocated */</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span>
<span class="nf">UA_Array_new</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Allocates and copies an array</span>
<span class="cm"> *</span>
<span class="cm"> * @param src The memory location of the source array</span>
<span class="cm"> * @param size The size of the array</span>
<span class="cm"> * @param dst The location of the pointer to the new array</span>
<span class="cm"> * @param type The datatype of the array members</span>
<span class="cm"> * @return Returns UA_STATUSCODE_GOOD or UA_STATUSCODE_BADOUTOFMEMORY */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Array_copy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">dst</span><span class="p">,</span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Resizes (and reallocates) an array. The last entries are initialized to zero</span>
<span class="cm"> * if the array length is increased. If the array length is decreased, the last</span>
<span class="cm"> * entries are removed if the size is decreased.</span>
<span class="cm"> *</span>
<span class="cm"> * @param p Double pointer to the array memory. Can be overwritten by the result</span>
<span class="cm"> *          of a realloc.</span>
<span class="cm"> * @param size The current size of the array. Overwritten in case of success.</span>
<span class="cm"> * @param newSize The new size of the array</span>
<span class="cm"> * @param type The datatype of the array members</span>
<span class="cm"> * @return Returns UA_STATUSCODE_GOOD or UA_STATUSCODE_BADOUTOFMEMORY. The</span>
<span class="cm"> *         original array is left untouched in the failure case. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Array_resize</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">newSize</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Append the given element at the end of the array. The content is moved</span>
<span class="cm"> * (shallow copy) and the original memory is _init&#39;ed if appending is</span>
<span class="cm"> * successful.</span>
<span class="cm"> *</span>
<span class="cm"> * @param p Double pointer to the array memory. Can be overwritten by the result</span>
<span class="cm"> *          of a realloc.</span>
<span class="cm"> * @param size The current size of the array. Overwritten in case of success.</span>
<span class="cm"> * @param newElem The element to be appended. The memory is reset upon success.</span>
<span class="cm"> * @param type The datatype of the array members</span>
<span class="cm"> * @return Returns UA_STATUSCODE_GOOD or UA_STATUSCODE_BADOUTOFMEMORY. The</span>
<span class="cm"> *         original array is left untouched in the failure case. */</span>
<span class="n">UA_StatusCode</span>
<span class="nf">UA_Array_append</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">newElem</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Append a copy of the given element at the end of the array.</span>
<span class="cm"> *</span>
<span class="cm"> * @param p Double pointer to the array memory. Can be overwritten by the result</span>
<span class="cm"> *          of a realloc.</span>
<span class="cm"> * @param size The current size of the array. Overwritten in case of success.</span>
<span class="cm"> * @param newElem The element to be appended.</span>
<span class="cm"> * @param type The datatype of the array members</span>
<span class="cm"> * @return Returns UA_STATUSCODE_GOOD or UA_STATUSCODE_BADOUTOFMEMORY. The</span>
<span class="cm"> *         original array is left untouched in the failure case. */</span>

<span class="n">UA_StatusCode</span>
<span class="nf">UA_Array_appendCopy</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">newElem</span><span class="p">,</span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="cm">/* Deletes an array.</span>
<span class="cm"> *</span>
<span class="cm"> * @param p The memory location of the array</span>
<span class="cm"> * @param size The size of the array</span>
<span class="cm"> * @param type The datatype of the array members */</span>
<span class="kt">void</span>
<span class="nf">UA_Array_delete</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UA_DataType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="generated-data-type-definitions">
<span id="generated-types"></span><h2>Generated Data Type Definitions<a class="headerlink" href="#generated-data-type-definitions" title="Link to this heading">¶</a></h2>
<p>The OPC UA standard defines many data types that are combinations of the 25
builtin data types. See the section on <a class="reference internal" href="generated.html#generated-definitions"><span class="std std-ref">Generated Definitions</span></a> for the
list of data types that are integrated for this build of the open62541
library.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Helper used to exclude type names in the definition of UA_DataType structures</span>
<span class="cm"> * if the feature is disabled. */</span>
<span class="cp">#ifdef UA_ENABLE_TYPEDESCRIPTION</span>
<span class="cp"># define UA_TYPENAME(name) name,</span>
<span class="cp">#else</span>
<span class="cp"># define UA_TYPENAME(name)</span>
<span class="cp">#endif</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;open62541/types_generated.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;open62541/types_generated_handling.h&gt;</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tutorial_pubsub_subscribe.html" class="btn btn-neutral float-left" title="Subscribing Fields" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="services.html" class="btn btn-neutral float-right" title="Services" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>